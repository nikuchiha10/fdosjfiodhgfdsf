# -*- coding: utf-8 -*-
"""
УТИЛИТЫ И ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ
Общие функции для всего проекта
"""

import logging
import time
import re
import os
from datetime import datetime, timedelta
from typing import List, Dict, Any, Optional, Union


class Логгер:
    """Класс для логирования событий парсера"""
    
    def __init__(self, путь_лога: str = None):
        """Инициализация логгера"""
        self.логгер = logging.getLogger('ПарсерБазыЗнаний')
        self.логгер.setLevel(logging.INFO)
        
        # Форматтер для логов
        форматтер = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s',
            datefmt='%Y-%m-%d %H:%M:%S'
        )
        
        # Обработчик для консоли
        консольный_обработчик = logging.StreamHandler()
        консольный_обработчик.setFormatter(форматтер)
        self.логгер.addHandler(консольный_обработчик)
        
        # Обработчик для файла
        if путь_лога:
            файловый_обработчик = logging.FileHandler(путь_лога, encoding='utf-8')
            файловый_обработчик.setFormatter(форматтер)
            self.логгер.addHandler(файловый_обработчик)
    
    def информация(self, сообщение: str):
        """Логирование информационного сообщения"""
        self.логгер.info(сообщение)
        print(f"[INFO] {сообщение}")
    
    def ошибка(self, сообщение: str):
        """Логирование сообщения об ошибке"""
        self.логger.error(сообщение)
        print(f"[ERROR] {сообщение}")
    
    def предупреждение(self, сообщение: str):
        """Логирование предупреждения"""
        self.логger.warning(сообщение)
        print(f"[WARNING] {сообщение}")
    
    def отладка(self, сообщение: str):
        """Логирование отладочной информации"""
        self.логger.debug(сообщение)
        print(f"[DEBUG] {сообщение}")


class Валидатор:
    """Класс для валидации данных"""
    
    @staticmethod
    def валидный_заголовок(заголовок: str) -> bool:
        """
        Проверка валидности заголовка статьи
        
        Args:
            заголовок: Заголовок для проверки
            
        Returns:
            bool: True если заголовок валиден
        """
        if not заголовок or not isinstance(заголовок, str):
            return False
        
        # Проверка длины
        if len(заголовок.strip()) < 5:
            return False
        
        # Проверка на системные слова
        системные_слова = Конфигурация.СИСТЕМНЫЕ_СЛОВА
        заголовок_нижний = заголовок.lower()
        
        for слово in системные_слова:
            if слово in заголовок_нижний and len(заголовок.strip()) < 20:
                return False
        
        # Проверка на специальные символы (только заголовки)
        if re.match(r'^[^a-zA-Zа-яА-Я0-9]{5,}$', заголовок):
            return False
        
        return True
    
    @staticmethod
    def валидный_url(url: str, базовый_домен: str = None) -> bool:
        """
        Проверка валидности URL
        
        Args:
            url: URL для проверки
            базовый_домен: Ожидаемый домен сайта
            
        Returns:
            bool: True если URL валиден
        """
        if not url or not isinstance(url, str):
            return False
        
        # Проверка исключаемых префиксов
        исключаемые_префиксы = Конфигурация.ИСКЛЮЧАЕМЫЕ_ПРЕФИКСЫ_URL
        for префикс in исключаемые_префиксы:
            if url.startswith(префикс):
                return False
        
        # Проверка домена если указан
        if базовый_домен and базовый_домен not in url:
            return False
        
        return True
    
    @staticmethod
    def очистить_текст(текст: str) -> str:
        """
        Очистка текста от лишних пробелов и символов
        
        Args:
            текст: Исходный текст
            
        Returns:
            str: Очищенный текст
        """
        if not текст:
            return ""
        
        # Удаление лишних пробелов и переносов строк
        текст = re.sub(r'\s+', ' ', текст)
        текст = re.sub(r'\n\s*\n', '\n\n', текст)
        
        # Удаление специальных символов (но сохранение кириллицы и пунктуации)
        текст = re.sub(r'[^\w\sа-яА-ЯёЁ.,!?;:()\-–—]', '', текст)
        
        return текст.strip()
    
    @staticmethod
    def извлечь_основной_текст(элемент) -> str:
        """
        Извлечение основного текста из элемента
        
        Args:
            элемент: WebElement или текст
            
        Returns:
            str: Извлеченный текст
        """
        try:
            if hasattr(элемент, 'text'):
                текст = элемент.text
            else:
                текст = str(элемент)
            
            return Валидатор.очистить_текст(текст)
        except Exception as e:
            return ""


class Форматировщик:
    """Класс для форматирования данных"""
    
    @staticmethod
    def форматировать_время(секунды: float) -> str:
        """
        Форматирование времени в читаемый вид
        
        Args:
            секунды: Количество секунд
            
        Returns:
            str: Отформатированное время
        """
        if not секунды:
            return "0 сек"
        
        время = timedelta(seconds=int(секунды))
        дни = время.days
        часы = время.seconds // 3600
        минуты = (время.seconds % 3600) // 60
        секунды = время.seconds % 60
        
        части = []
        if дни > 0:
            части.append(f"{дней} д")
        if часы > 0:
            части.append(f"{часы} ч")
        if минуты > 0:
            части.append(f"{минуты} м")
        if секунды > 0 or not части:
            части.append(f"{секунды} с")
        
        return " ".join(части)
    
    @staticmethod
    def форматировать_размер_файла(байты: int) -> str:
        """
        Форматирование размера файла
        
        Args:
            байты: Размер в байтах
            
        Returns:
            str: Отформатированный размер
        """
        if байты < 1024:
            return f"{байты} Б"
        elif байты < 1024 * 1024:
            return f"{байты / 1024:.1f} КБ"
        else:
            return f"{байты / (1024 * 1024):.1f} МБ"
    
    @staticmethod
    def создать_структуру_файла(статьи: List[Dict]) -> str:
        """
        Создание структуры TXT файла
        
        Args:
            статьи: Список статей
            
        Returns:
            str: Текст файла
        """
        текущее_время = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        заголовок = f"=== БАЗА ЗНАНИЙ - {len(статьи)} СТАТЕЙ ===\n"
        заголовок += f"Время сбора: {текущее_время}\n\n"
        
        содержимое = ""
        
        for индекс, статья in enumerate(статьи, 1):
            содержимое += f"СТАТЬЯ {индекс}: {статья.get('заголовок', 'Нет заголовка')}\n"
            содержимое += f"URL: {статья.get('url', 'Нет URL')}\n"
            содержимое += f"Тип: {статья.get('тип', 'Неизвестно')}\n"
            содержимое += f"Время обработки: {статья.get('время_обработки', '0')}с\n\n"
            
            # Заголовки
            заголовки = статья.get('заголовки', [])
            if заголовки:
                содержимое += f"ЗАГОЛОВКИ: {' | '.join(заголовки[:3])}\n"
            else:
                содержимое += "ЗАГОЛОВКИ: Нет заголовков\n"
            
            # Текст (первые 200 символов)
            текст = статья.get('текст', '')
            if текст:
                превью_текста = текст[:200] + "..." if len(текст) > 200 else текст
                содержимое += f"ТЕКСТ: {превью_текста}\n"
            else:
                содержимое += "ТЕКСТ: Нет текста\n"
            
            # Внутренние разделы
            разделы = статья.get('внутренние_разделы', [])
            if разделы:
                содержимое += "ВНУТРЕННИЕ РАЗДЕЛЫ:\n"
                for раздел in разделы[:5]:  # Ограничиваем 5 разделами
                    название = раздел.get('название', 'Без названия')
                    содержание = раздел.get('содержание', '')[:100]
                    содержимое += f"• {название}: {содержание}...\n"
            else:
                содержимое += "ВНУТРЕННИЕ РАЗДЕЛЫ: Нет разделов\n"
            
            содержимое += "\n" + "="*50 + "\n\n"
        
        # Статистика в конце
        статистика = "\n📊 СТАТИСТИКА СБОРА:\n"
        статистика += f"• Всего статей: {len(статьи)}\n"
        
        общее_количество_разделов = sum(len(ст.get('внутренние_разделы', [])) for ст in статьи)
        статистика += f"• Внутренних разделов: {общее_количество_разделов}\n"
        
        общее_время = sum(ст.get('время_обработки', 0) for ст in статьи)
        статистика += f"• Общее время обработки: {Форматировщик.форматировать_время(общее_время)}\n"
        
        if общее_время > 0:
            скорость = len(статьи) / (общее_время / 60)
            статистика += f"• Средняя скорость: {скорость:.1f} статей/мин\n"
        
        return заголовок + содержимое + статистика


class ОбработчикОшибок:
    """Класс для обработки ошибок"""
    
    def __init__(self, логгер: Логгер):
        self.логгер = логгер
        self.количество_ошибок = 0
    
    def обработать_ошибку(self, ошибка: Exception, контекст: str = "") -> str:
        """
        Обработка ошибки с логированием
        
        Args:
            ошибка: Объект исключения
            контекст: Контекст возникновения ошибки
            
        Returns:
            str: Сообщение об ошибке
        """
        self.количество_ошибок += 1
        
        сообщение_об_ошибке = f"{контекст}: {str(ошибка)}" if контекст else str(ошибка)
        
        self.логгер.ошибка(сообщение_об_ошибке)
        
        return сообщение_об_ошибке
    
    def получить_статистику_ошибок(self) -> Dict[str, Any]:
        """
        Получение статистики по ошибкам
        
        Returns:
            Dict: Статистика ошибок
        """
        return {
            "количество_ошибок": self.количество_ошибок,
            "время_последней_ошибки": datetime.now().isoformat() if self.количество_ошибок > 0 else None
        }


# Глобальные экземпляры
логгер = Логгер()
валидатор = Валидатор()
форматировщик = Форматировщик()
